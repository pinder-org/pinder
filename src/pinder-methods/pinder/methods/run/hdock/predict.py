from __future__ import annotations
import os
import shutil
import subprocess
import tempfile
from pathlib import Path
from typing import Any

from pinder.core.utils import setup_logger

log = setup_logger(__name__)


def _normalize_hdock_pdb(fname: Path) -> None:
    """

    Normalize the PDB file by fixing the format generated by HDOCKLite:
        - remove non-ATOM records
        - set occupancy to 1.0
        - set temp factor to 0.0
    """
    from biotite.structure.io.pdb import PDBFile

    with open(fname, "r") as f:
        lines = f.readlines()

    with open(fname, "w") as f:
        for line in lines:
            # only save ATOM records
            if line.startswith("ATOM"):
                # occupancy
                line = line[:54] + "{:6.2f}".format(1.0) + line[60:]
                # temp factor
                line = line[:60] + "{:6.2f}".format(0.0) + line[66:]
                f.write(line + "\n")

    model = PDBFile.read(fname)
    array_stack = model.get_structure(model=1)  # noqa
    pdb_file = PDBFile()
    pdb_file.set_structure(array_stack)
    pdb_file.write(fname)


def hdock(
    results_dir: Path,
    n_solutions: int,
    complex_id: str,
    complex_kind: str,
    complex_receptor: Path,
    complex_ligand: Path,
) -> None:
    """Run HDockLite on a single receptor-ligand complex and generate `n_solutions` docking solutions.
    Assume that all paths provided are local and all the files exist.
    Assume that `hdock` binary is available in PATH.
    Save results to the specified `results_dir`. Directory will be created if needed.

    Parameters
    ----------
    results_dir : Path
        Path to the docking dataset.
        resulting path will be: `{results_dir}/hdock/{id}/{kind}_decoys/model_{i}.pdb`
    n_solutions : int
        Number of solutions `i = {1..n_solutions}` to generate.
    id : str
        PINDER ID of the complex.
    kind : str
        `holo`, `apo` or `predicted`.
    receptor : Path
        All structures are expected to be pre-transformed and ready for docking.
    ligand : Path
        All structures are expected to be pre-transformed and ready for docking.

    """
    log.info(
        f"Running HDockLite ({n_solutions} solutions) on complex {complex_id} {complex_kind} {complex_receptor} {complex_ligand}"
    )

    current_dir = os.getcwd()
    output_dir = Path(tempfile.mkdtemp())
    log.info("OUT", output_dir)
    os.chdir(output_dir)

    dock_path = shutil.which("hdock")
    if not dock_path:
        log.error("hdock binary not found on $PATH!")
        # restore CWD
        os.chdir(current_dir)
        return

    # file prefices
    R_file_name = complex_receptor.name
    L_file_name = complex_ligand.name

    receptor = R_file_name.split(".")[0]
    ligand = L_file_name.split(".")[0]

    # Define the docking stages
    stages = [
        (
            "STAGE-1 FFT Docking",
            f"{dock_path}/hdock {receptor}.pdb {ligand}.pdb -out hdock.out",
        ),
        (
            f"STAGE-2 Generate top {n_solutions} solutions",
            f"{dock_path}/createpl hdock.out top{n_solutions}.pdb -nmax {n_solutions} -complex -models",
        ),
    ]
    # Execute the stages sequentially
    for stage_name, cmd in stages:
        log.debug(stage_name)
        log.debug(cmd)
        try:
            subprocess.run(cmd, shell=True)
            # optionally redirect stderr to stdout
            # subprocess.run(cmd, shell=True, stderr=subprocess.STDOUT)
        except Exception as e:
            log.error(f"ERROR while running stage {stage_name} on {complex_id}: {e}")
            os.chdir(current_dir)
            return

    solutions_exist = True
    for i in range(1, n_solutions + 1):
        if not Path(f"model_{i}.pdb").exists():
            solutions_exist = False

    if not solutions_exist:
        log.info(f"ERROR: {complex_kind} {complex_id} did not finish successfully")
        os.chdir(current_dir)
        return

    # delete extra files
    for fname in Path(".").glob("*.pdb"):
        if "model_" not in fname.name:
            fname.unlink()

    # normalize the results by renaming the top solutions
    for i in range(1, n_solutions + 1):
        _normalize_hdock_pdb(Path(f"model_{i}.pdb"))

    # change back to original working directory
    os.chdir(current_dir)
    # copy the results
    results_path_complete = results_dir / f"hdock/{complex_id}/{complex_kind}_decoys/"
    log.info(f"Copying the results to {results_path_complete}")
    results_path_complete.mkdir(parents=True, exist_ok=True)
    shutil.copy(str(output_dir) + "/*.pdb", results_path_complete)


def predict_hdock(
    complex_config: dict[str, str | Path], params: dict[str, Any]
) -> None:
    """
    Run HDockLite on a single receptor-ligand complex and generate `n_solutions` docking solutions.
    Assume that all the specified paths are local and the files exist.
    Save results to the specified `results_dir`. Directory is created if needed.

    Parameters
    ----------
    complex_config : dict[str, str | Path]
        Dictionary containing configuration for the complex.

        id : str
            PINDER ID of the complex.
        kind : str
            `holo`, `apo` or `predicted`.
        receptor : Path
            All structures are expected to be pre-transformed and ready for docking.
        ligand : Path
            All structures are expected to be pre-transformed and ready for docking.
    params : dict[str, Any]
        Dictionary containing additional parameters.

        results_dir : Path
            Path to the docking dataset.
            Resulting path will be: `{results_dir}/hdock/{id}/{kind}_decoys/model_{i}.pdb`.
        n_solutions : int
            Number of solutions `i = {1..n_solutions}` to generate.
        force : bool
            Force re-running the docking even if the results already exist.
    """
    complex_id = str(complex_config["id"])
    complex_kind = str(complex_config["kind"])
    complex_receptor = Path(complex_config["receptor"])
    complex_ligand = Path(complex_config["ligand"])
    results_dir = Path(params["results_dir"])
    n_solutions = int(params["n_solutions"])
    force = bool(params["force"])

    results_path_complete = results_dir / f"hdock/{complex_id}/{complex_kind}_decoys/"
    if not force and (results_path_complete / "model_1.pdb").exists():
        log.info(
            f"Skipping {complex_id} {complex_kind} because it already exists in {results_path_complete}"
        )
        return

    hdock(
        results_dir,
        n_solutions,
        complex_id,
        complex_kind,
        complex_receptor,
        complex_ligand,
    )
